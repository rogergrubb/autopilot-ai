/**
 * Document creation â€” generates files in various formats.
 * Returns base64-encoded content for download.
 * 
 * Uses pdf-lib (pure JS, no file system deps) for serverless compatibility.
 */

import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';

interface DocumentResult {
  success: boolean;
  fileName?: string;
  mimeType?: string;
  base64?: string;
  downloadUrl?: string;
  error?: string;
}

async function generatePdf(title: string, content: string, fileName: string): Promise<DocumentResult> {
  try {
    const pdfDoc = await PDFDocument.create();
    const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

    const pageWidth = 612;
    const pageHeight = 792;
    const margin = 50;
    const maxWidth = pageWidth - margin * 2;

    let page = pdfDoc.addPage([pageWidth, pageHeight]);
    let y = pageHeight - margin;

    function ensureSpace(needed: number) {
      if (y - needed < margin) {
        page = pdfDoc.addPage([pageWidth, pageHeight]);
        y = pageHeight - margin;
      }
    }

    function wrapText(text: string, font: typeof helvetica, size: number): string[] {
      const words = text.split(' ');
      const lines: string[] = [];
      let currentLine = '';
      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        const testWidth = font.widthOfTextAtSize(testLine, size);
        if (testWidth > maxWidth && currentLine) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) lines.push(currentLine);
      return lines;
    }

    function drawText(text: string, font: typeof helvetica, size: number, color = rgb(0.2, 0.2, 0.2)) {
      const lines = wrapText(text, font, size);
      const lineHeight = size * 1.4;
      for (const line of lines) {
        ensureSpace(lineHeight);
        page.drawText(line, { x: margin, y, font, size, color });
        y -= lineHeight;
      }
    }

    // Title
    const titleLines = wrapText(title, helveticaBold, 22);
    for (const line of titleLines) {
      page.drawText(line, { x: margin, y, font: helveticaBold, size: 22, color: rgb(0.1, 0.1, 0.1) });
      y -= 30;
    }
    y -= 5;

    const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    page.drawText(`Generated by AutoPilot AI - ${dateStr}`, {
      x: margin, y, font: helvetica, size: 9, color: rgb(0.5, 0.5, 0.5),
    });
    y -= 25;

    page.drawLine({
      start: { x: margin, y },
      end: { x: pageWidth - margin, y },
      thickness: 1,
      color: rgb(0.8, 0.8, 0.8),
    });
    y -= 20;

    const contentLines = content.split('\n');
    for (const line of contentLines) {
      if (line.startsWith('### ')) {
        y -= 8;
        ensureSpace(20);
        drawText(line.replace('### ', ''), helveticaBold, 13, rgb(0.25, 0.25, 0.25));
        y -= 4;
      } else if (line.startsWith('## ')) {
        y -= 12;
        ensureSpace(24);
        drawText(line.replace('## ', ''), helveticaBold, 16, rgb(0.15, 0.15, 0.15));
        y -= 6;
      } else if (line.startsWith('# ')) {
        y -= 16;
        ensureSpace(28);
        drawText(line.replace('# ', ''), helveticaBold, 20, rgb(0.1, 0.1, 0.1));
        y -= 8;
      } else if (line.match(/^[-*]\s/)) {
        drawText('  \u2022  ' + line.replace(/^[-*]\s/, ''), helvetica, 11);
      } else if (line.match(/^\d+\.\s/)) {
        drawText('  ' + line, helvetica, 11);
      } else if (line.trim() === '') {
        y -= 8;
      } else {
        drawText(line, helvetica, 11);
      }
    }

    const pdfBytes = await pdfDoc.save();
    const base64 = Buffer.from(pdfBytes).toString('base64');

    return { success: true, fileName, mimeType: 'application/pdf', base64 };
  } catch (error: unknown) {
    return { success: false, error: `PDF generation failed: ${(error as Error).message}` };
  }
}

function generateCsv(content: string, fileName: string): DocumentResult {
  return { success: true, fileName, mimeType: 'text/csv', base64: Buffer.from(content, 'utf-8').toString('base64') };
}

function generateHtml(title: string, content: string, fileName: string): DocumentResult {
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 800px; margin: 0 auto; padding: 40px 20px; color: #333; line-height: 1.6; }
    h1 { color: #111; border-bottom: 2px solid #4a7c59; padding-bottom: 10px; }
    h2 { color: #222; margin-top: 30px; }
    h3 { color: #444; }
    table { border-collapse: collapse; width: 100%; margin: 20px 0; }
    th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
    th { background: #f5f5f5; font-weight: 600; }
    .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; color: #888; font-size: 0.85em; }
  </style>
</head>
<body>
  <h1>${title}</h1>
  ${content}
  <div class="footer">Generated by AutoPilot AI</div>
</body>
</html>`;
  return { success: true, fileName, mimeType: 'text/html', base64: Buffer.from(html, 'utf-8').toString('base64') };
}

function generateTextFile(content: string, fileName: string, mimeType: string): DocumentResult {
  return { success: true, fileName, mimeType, base64: Buffer.from(content, 'utf-8').toString('base64') };
}

function generateJson(content: string, fileName: string): DocumentResult {
  try { JSON.parse(content); } catch { content = JSON.stringify({ data: content }, null, 2); }
  return { success: true, fileName, mimeType: 'application/json', base64: Buffer.from(content, 'utf-8').toString('base64') };
}

export async function createDocument(
  format: 'pdf' | 'csv' | 'html' | 'markdown' | 'json' | 'txt' | 'tsv',
  title: string,
  content: string,
  fileName?: string
): Promise<DocumentResult> {
  const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
  const defaultFileName = `${slug}.${format === 'markdown' ? 'md' : format}`;
  const finalFileName = fileName || defaultFileName;

  switch (format) {
    case 'pdf': return generatePdf(title, content, finalFileName);
    case 'csv': return generateCsv(content, finalFileName);
    case 'tsv': return generateTextFile(content, finalFileName, 'text/tab-separated-values');
    case 'html': return generateHtml(title, content, finalFileName);
    case 'markdown': return generateTextFile(content, finalFileName, 'text/markdown');
    case 'json': return generateJson(content, finalFileName);
    case 'txt': return generateTextFile(content, finalFileName, 'text/plain');
    default: return { success: false, error: `Unsupported format: ${format}` };
  }
}
