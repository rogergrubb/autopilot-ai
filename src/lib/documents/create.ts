/**
 * Document creation — generates files in various formats.
 * Returns base64-encoded content for download.
 * 
 * Supported formats: PDF, CSV, HTML, Markdown, JSON, TXT, TSV
 */

interface DocumentResult {
  success: boolean;
  fileName?: string;
  mimeType?: string;
  base64?: string;
  downloadUrl?: string;
  error?: string;
}

/**
 * Generate a PDF document from text content.
 * Uses a simple text-based approach that works in serverless.
 */
async function generatePdf(title: string, content: string, fileName: string): Promise<DocumentResult> {
  try {
    const PDFDocument = (await import('pdfkit')).default;
    
    return new Promise((resolve) => {
      const doc = new PDFDocument({
        margin: 50,
        size: 'letter',
        info: { Title: title, Author: 'AutoPilot AI' },
      });

      const chunks: Buffer[] = [];
      doc.on('data', (chunk: Buffer) => chunks.push(chunk));
      doc.on('end', () => {
        const buffer = Buffer.concat(chunks);
        const base64 = buffer.toString('base64');
        resolve({
          success: true,
          fileName,
          mimeType: 'application/pdf',
          base64,
        });
      });

      // Title
      doc.fontSize(24).font('Helvetica-Bold').text(title, { align: 'center' });
      doc.moveDown(1);
      doc.fontSize(9).font('Helvetica').fillColor('#888888')
        .text(`Generated by AutoPilot AI — ${new Date().toLocaleDateString()}`, { align: 'center' });
      doc.moveDown(2);

      // Content — handle markdown-like headers
      const lines = content.split('\n');
      for (const line of lines) {
        if (line.startsWith('### ')) {
          doc.moveDown(0.5);
          doc.fontSize(14).font('Helvetica-Bold').fillColor('#333333').text(line.replace('### ', ''));
          doc.moveDown(0.3);
        } else if (line.startsWith('## ')) {
          doc.moveDown(0.5);
          doc.fontSize(16).font('Helvetica-Bold').fillColor('#222222').text(line.replace('## ', ''));
          doc.moveDown(0.3);
        } else if (line.startsWith('# ')) {
          doc.moveDown(0.8);
          doc.fontSize(20).font('Helvetica-Bold').fillColor('#111111').text(line.replace('# ', ''));
          doc.moveDown(0.5);
        } else if (line.startsWith('- ') || line.startsWith('* ')) {
          doc.fontSize(11).font('Helvetica').fillColor('#333333').text(`  •  ${line.replace(/^[-*] /, '')}`, { indent: 15 });
        } else if (line.trim() === '') {
          doc.moveDown(0.5);
        } else {
          doc.fontSize(11).font('Helvetica').fillColor('#333333').text(line);
        }
      }

      doc.end();
    });
  } catch (error: unknown) {
    return { success: false, error: `PDF generation failed: ${(error as Error).message}` };
  }
}

/**
 * Generate a CSV file.
 */
function generateCsv(content: string, fileName: string): DocumentResult {
  const base64 = Buffer.from(content, 'utf-8').toString('base64');
  return {
    success: true,
    fileName,
    mimeType: 'text/csv',
    base64,
  };
}

/**
 * Generate an HTML document.
 */
function generateHtml(title: string, content: string, fileName: string): DocumentResult {
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 800px; margin: 0 auto; padding: 40px 20px; color: #333; line-height: 1.6; }
    h1 { color: #111; border-bottom: 2px solid #4a7c59; padding-bottom: 10px; }
    h2 { color: #222; margin-top: 30px; }
    h3 { color: #444; }
    table { border-collapse: collapse; width: 100%; margin: 20px 0; }
    th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
    th { background: #f5f5f5; font-weight: 600; }
    code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-size: 0.9em; }
    pre { background: #f4f4f4; padding: 16px; border-radius: 8px; overflow-x: auto; }
    .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; color: #888; font-size: 0.85em; }
  </style>
</head>
<body>
  <h1>${title}</h1>
  ${content}
  <div class="footer">Generated by AutoPilot AI — ${new Date().toLocaleDateString()}</div>
</body>
</html>`;

  const base64 = Buffer.from(html, 'utf-8').toString('base64');
  return {
    success: true,
    fileName,
    mimeType: 'text/html',
    base64,
  };
}

/**
 * Generate a plain text or markdown document.
 */
function generateTextFile(content: string, fileName: string, mimeType: string): DocumentResult {
  const base64 = Buffer.from(content, 'utf-8').toString('base64');
  return {
    success: true,
    fileName,
    mimeType,
    base64,
  };
}

/**
 * Generate a JSON document.
 */
function generateJson(content: string, fileName: string): DocumentResult {
  // Validate JSON
  try {
    JSON.parse(content);
  } catch {
    // If not valid JSON, wrap it
    content = JSON.stringify({ data: content }, null, 2);
  }

  const base64 = Buffer.from(content, 'utf-8').toString('base64');
  return {
    success: true,
    fileName,
    mimeType: 'application/json',
    base64,
  };
}

/**
 * Main document creation function — dispatches to the right generator.
 */
export async function createDocument(
  format: 'pdf' | 'csv' | 'html' | 'markdown' | 'json' | 'txt' | 'tsv',
  title: string,
  content: string,
  fileName?: string
): Promise<DocumentResult> {
  // Auto-generate filename
  const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
  const defaultFileName = `${slug}.${format === 'markdown' ? 'md' : format}`;
  const finalFileName = fileName || defaultFileName;

  switch (format) {
    case 'pdf':
      return generatePdf(title, content, finalFileName);
    case 'csv':
      return generateCsv(content, finalFileName);
    case 'tsv':
      return generateTextFile(content, finalFileName, 'text/tab-separated-values');
    case 'html':
      return generateHtml(title, content, finalFileName);
    case 'markdown':
      return generateTextFile(content, finalFileName, 'text/markdown');
    case 'json':
      return generateJson(content, finalFileName);
    case 'txt':
      return generateTextFile(content, finalFileName, 'text/plain');
    default:
      return { success: false, error: `Unsupported format: ${format}` };
  }
}
